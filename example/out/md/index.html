<!-- "doc" type, with tabs usage as template--><!-- Author: Kevin Cyu--><!-- include mixins--><!-- mixin - list--><!-- main--><!DOCTYPE html><html><!-- include header--><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Power by papoGen</title><link rel="stylesheet" href="./asset/highlight.min.css"><link rel="stylesheet" href="./asset/paper.min.css"><link rel="stylesheet" href="./asset/monokai.css"><link rel="stylesheet" href="./asset/main.css"><link rel="stylesheet" href="./asset/cn-font.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({jax: ["input/TeX", "output/HTML-CSS"],extensions: ["tex2jax.js"],"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },messageStyle: "none"});</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="./asset/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="container"><div class="paper"><div class="demo-title" id="top"><div class="row flex-center"><div class="text-center"> <h1 class=".cn" id="Power%20by papoGen">Power by papoGen</h1></div></div></div><div class="section"><div class="flex-spaces tabs">
<input id="tab1" type="radio" name="tabs" checked="">
<label id="label_tab1" for="tab1">01-tutte's theorem</label>

<input id="tab2" type="radio" name="tabs">
<label id="label_tab2" for="tab2">02-mathJax</label>

<div class="content" id="content1"><p></p><h1 id="Tutte's%20theorem">Tutte's theorem</h1>
<p>由 Tutte 於 1947 年提出，理論為 <code>A graph G has a 1-factor iff o(G-S)&lt;=|S| for every S ⊆ V(G)</code>，而是理論也稱為該 graph G 的 <code>Tutte's Condition</code></p>
<ul>
<li><code>o(G)</code>: 表示 graph G 的 odd components 的數量</li>
<li><code>1-factor</code>: 等於 perfact matching 的狀態</li>
<li><code>V(G)</code>: 表示 graph G 的 vertex 集合</li>
</ul>
<p>並且可以知道其幾項性質：</p>
<ul>
<li>G 為一個 simple graph，vertex 數量記為 <code>n (e.g. = n(G))</code></li>
<li>o(G) ≡ n (mod 2), 指的是 o(G) 及 n(G) 同時為 even、或是同時為 odd
<ul>
<li>≡: "定義"、"恆等於"</li>
</ul>
</li>
<li>For S ⊆ V:
<ul>
<li>o(G-S) ≡ n(G-S) = n - |S| (mod 2)</li>
<li>|S| + o(G-S) ≡ n(G) (mod 2) <code>- 式(1)</code></li>
</ul>
</li>
<li>而從 Tutte condition 可得第2式：
<ul>
<li>∀S ⊂ V : <code>o(G − S) ≤ |S|</code>, <code>- 式(2)</code>
<ul>
<li>∀: "任意存在"</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="證明與概念詳細解釋" class=" cn">證明與概念詳細解釋</h1>
<p>從正向（<code>Necessity</code>）與反向（<code>Sufficiency</code>）證明</p>
<h2 id="Necessity（必要性）" class=" cn">Necessity（必要性）</h2>
<ul>
<li>正面從 G 是為一個 1-factor 的圖做解釋，可以知道以這種情況下可以畫出圖形：</li>
</ul>
<p><img src="https://github.com/toolbuddy/Graph-Theory/blob/master/res/ch3/g-tutte-ne.png?raw=true" alt=""></p>
<ul>
<li>以性質來看
<ul>
<li>S 屬於 V(G)，而所有屬於 <code>G-S</code> 的 odd components 皆有一條 edge 連到 <code>S</code> 上</li>
<li>而連到 S 內，則表示在 S 中必有同等數目的 vertices 與這條 edge 做對應的 endpoint，且互為 unique（不會重複使用 endpoint）</li>
</ul>
</li>
<li>透過<strong>鴿籠原理</strong>，我們可以知道，以上圖為例，S 上有 3 個 odd components 與之連線，有 3 條 edges 進 S 當中，與之對應必有 3 個 unique 的 vertex，則 <code>|S| &gt;= o(G-S)</code> 這條式子必成立</li>
</ul>
<pre><code>從正面去證明是直觀，並且簡單的；
而接下來是 tutte 的精華
</code></pre>
<hr>
<h2 id="Sufficiency（充份性）" class=" cn">Sufficiency（充份性）</h2>
<ul>
<li>這邊是從後面性質證回來，也就是說明擁有 <code>o(G-S) &lt;= |S|</code> 性質的 graph，其必有 1-factor（perfact matching）的存在
<ul>
<li>== 假如 G 符合 Tutte's condition，則其有一 perfect matching (<code>1-factor</code>)</li>
</ul>
</li>
<li>而我們可以使用反證法（擁有 <code>o(G-S) &lt;= |S|</code> 性質，卻沒有 <code>1-factor</code>）來做證明，透過相同模型（分兩邊做討論），來分析各種情況，舉出擁有 <code>1-factor</code> 的實例，說明此假設錯誤，tutte's theorem 為真</li>
</ul>
<h3 id="先從假設的狀況下手" class=" cn">先從假設的狀況下手</h3>
<ul>
<li>首先我們設定 S 為<code>空集合</code>，這樣從<code>式(2)</code>中可以得到 <em>o(G-S) = o(G) ≤ |S| = 0</em>，所以從<code>式(1)</code>當中可以知道 <code>n(G)</code> 是 even<pre><code>o(G-∅) = o(G) = 0, 表示沒有奇數 component!
而此代表，graph G 的中 vertex 數量必定為 even !
</code></pre>
</li>
</ul>
<h3 id="Claim%201">Claim 1</h3>
<p>增加一條 edge 並<code>維持 Tutte Condition</code>，也就是說，假設 e ∈ E(H)，而 H - e 符合 Tutte Condition（ 這個 H 就是加完 edge 並符合 Tutte Condition 的結果 ）</p>
<ul>
<li>
<p>如何證明？</p>
<ul>
<li>我們可以先預設認為 <code>H - e</code> 符合 Tutte Condition</li>
<li>而現在找一個 S，S ⊆ V (H)，屬於 H 的 vertex 集合</li>
<li>當 e 的其中一個 endpoint 在 S 之中時，則 <code>H - S = H - e - S</code> ，這麼一來，便可以知道：</li>
</ul>
<pre><code>o(H - S) = o(H - e - S) ≤ |S|
</code></pre>
<ul>
<li>否則，假設 J, J' 為 <code>H - e - S</code> 中的 Component，其內包含了 e 的 endpoint； 則可知其性質可分為以下幾種：</li>
</ul>
<p><img src="https://github.com/toolbuddy/Graph-Theory/blob/master/res/ch3/g-tutte-J.png?raw=true" alt=""></p>
<ul>
<li>而這幾種 case 都符合 <code>o(H - S) ≤ o(H - e - S) ≤ |S|</code>，則證明了 <em>Claim 1</em> 的假設符合 Tutte Condition</li>
</ul>
</li>
<li>
<p>因此，假設 1-factor 的存在性並不足以使 graph 擁有 Tutte Condition 的話，則我們可以選擇一個 <code>Maximal counterexample G</code>，使這個 G 擁有幾項特性：</p>
<ul>
<li>G 符合 Tutte Condition</li>
<li>但 G 沒有 1-factor</li>
<li>並且加入任何 single edge 進入 G <code>便可以產生一個 1-factor 的 graph</code> （也就是目前的 G 是達飽和狀態前的 graph）</li>
</ul>
</li>
</ul>
<h3 id="Claim%202">Claim 2</h3>
<p>有了以上的認知後，我們可以接下來做；使用多個狀態來展示矛盾狀況即可證明。</p>
<ul>
<li>Idea:
<ul>
<li>使用了 U 這個集合，並且我們把重點放在<em>分析 G - U</em>這個部份</li>
<li>U 的性質
<ul>
<li>其內每個 vertex 的 degree 階為 n-1 (除了自己之外，對 graph G 內的每個 vertex 都有 edge 連通)</li>
</ul>
</li>
</ul>
<pre><code>U =  {v ∈ V | N(v) = V − {v} = {v ∈ V | dG(v) = n − 1}.
N(v) 為 v 的 neighbor 集合，可以看到其集合為整個 Vertex Set，除自己以外的所有其他 vertex
</code></pre>
</li>
<li>有了以上的認知後，我們可以<code>針對 G-U ，來先分為兩個情況下去做討論</code></li>
</ul>
<h4>Case 1</h4>
<p><code>G-U</code> 是為互不相連的 cliques（complete graph） 組成，如下圖所示：</p>
<p><img src="https://github.com/toolbuddy/Graph-Theory/blob/master/res/ch3/g-tutte-case1.png?raw=true" alt=""></p>
<ul>
<li>
<p>而灰色的點則為 U，在圖中不畫出這些 U 內 vertex 的 edge</p>
</li>
<li>
<p>計算 o(G-U) = 4</p>
<ul>
<li>在圖中，有兩個 isolated vertices、一個 3-clique 以及一個 7-clique</li>
</ul>
</li>
<li>
<p>|U| = 8</p>
<ul>
<li>透過 Tutte condition 以及 <code>式(1)</code>，U 擁有相同的性質： 大於等於 o(G-U)</li>
</ul>
</li>
<li>
<p>接著可以建立 G-U 的 Maximum matching <em>M</em> (下圖中的紅色 edge)，試圖感染所有 G-U 的 components 中所有的 vertices</p>
<ul>
<li>odd component 中的情況會是<code>必有一個 vertex 無法被 matching 所感染</code></li>
<li>而 even component 則是完美的感染完畢</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/toolbuddy/Graph-Theory/blob/master/res/ch3/g-tutte-case1-red.png?raw=true" alt=""></p>
<ul>
<li>接下來便是繼續加大這個 matching，以達到 graph G 的 perfect matching <em>M'</em>
<ul>
<li>剛剛的步驟後，剩餘未被感染的 vertex 都在 odd components 當中</li>
<li>所以我們可以透過讓這些 <em>未被感染者</em>，與 U 內的 vertex 建立 edge，來完成感染（下圖中綠色的部份）</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/toolbuddy/Graph-Theory/blob/master/res/ch3/g-tutte-case1-green.png?raw=true" alt=""></p>
<ul>
<li>
<p>到此為止，graph 當中沒有 matched 的 vertices 數量為 <code>|U| - o(G-U)</code></p>
<ul>
<li>這些 vertices 都屬於 U，並且以 U 的性質來看，他們都是<code>成對、並且相鄰的（其 degree 為所有 vertex 數量減 1）</code></li>
<li>而這些 vertices 數量為偶數；</li>
</ul>
<pre><code>
為何為偶數？
Ans: 因為可以從前面得知，目前 graph 的組成使用到了：
(1) 偶數的 components -&gt; 提供 even number 的 vertices
(2) 奇數的 components -&gt; 提供 odd number 的 vertices
(3) 而 U 內與奇數 components 相連使用的 vertices -&gt; odd
而在一開始假設那段，我們可以知道再情況下， graph 的 vertice 總數量為 even ！
那麼從上面可知，even（總數）- even（偶數 comp.）- odd（奇數 comp.） - odd（U 內對應的 vertices）後的結果，必為偶數！(U 內剩餘的 vertices)

</code></pre>
<ul>
<li>由於剩餘的互相為 pairwise adjacent vertices，這些 vertice 可以自行形成 perfect matching (下圖中藍色部份)</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/toolbuddy/Graph-Theory/blob/master/res/ch3/g-tutte-case1-blue.png?raw=true" alt=""></p>
<p>這麼一來，Case 1 的狀態便分析完畢</p>
<h4>Case 2</h4>
<p><code>G-U</code> 並非互不相連的 cliques（complete graph）的情形。如下圖：</p>
<p><img src="https://github.com/toolbuddy/Graph-Theory/blob/master/res/ch3/g-tutte-case2.png?raw=true" alt=""></p>
<ul>
<li>
<p>設 H 為其中一個 <code>G-U</code> 中的 component，並且不為 clique.</p>
<ul>
<li>其至少有 3 個 vertices，其中兩個之間的距離必為 2（因為其不為 clique 的緣故）；比如上圖中 H 內的 <code>x</code>, <code>z</code></li>
<li>而 <code>x</code>, <code>z</code> 中有一個相同的鄰居 <code>y</code></li>
<li>並且存在一個 <code>w</code>，其屬於 G-U 的 vertex set 當中，並且 wy 之間的 edge 並不存在</li>
</ul>
<pre><code>注意：
w 可能不一定屬於 H
</code></pre>
<ul>
<li>相同地，灰色的 vertices 表示 U 集合，每個 vertex 的 edge 都忽略不畫上去（影響重點）</li>
</ul>
</li>
<li>
<p>回到 G 的部份，當加入一個 single edge 進 G 後，則會產生一個 perfect matching； 根據此，我們假設了兩個 matching - <code>M1(藍色) = G + xz</code> 以及 <code>M2(紅色) = G + wy</code>，如下圖所示：</p>
</li>
</ul>
<p><img src="https://github.com/toolbuddy/Graph-Theory/blob/master/res/ch3/g-tutte-case2-m1m2.png?raw=true" alt=""></p>
<ul>
<li>當中，虛線的 xz, wy 並不屬於 G</li>
<li>設 F = M1 及 M2 的 symmetric difference；而 xz,wy 則屬於 F
<ul>
<li>透過先前的 Lemma 所知， F 內的 component 為一條 <code>path</code> 或是 <code>even cycle</code></li>
<li>而實際上，當 F 內 component 是為 path 時，表示這些都是 isolated 的 vertex；否則其 endpoints 就不會被 M1 或是 M2 所感染</li>
</ul>
</li>
<li>以上圖看，則 component C 是為包含 xz 的 even cycle</li>
</ul>
<p>而針對這個 component C 再下去做分析，則可以再分為兩個 case 做討論：</p>
<h5>Case 2A</h5>
<p>yw 不屬於 C 時，則 M1 與 C 取 symmetric difference 的結果等於 <code>M2 與 E（C）取交集</code> 再與 <code>M1 扣除 E（C）後的結果</code>做<em>聯集</em>，其結果為一 perfect matching 且不包含 xz 或是 wy，合法屬於 G 的 perfect matching</p>
<h5>Case 2B</h5>
<p>yw 屬於 C，則我們可以稍微改一下上面圖，並標示出每個屬於 C 的 vertex: w,y,a1,a2,...,a<code>p</code>,z,x,b1,b2,...,b<code>q</code></p>
<ul>
<li>
<p>其中上面的 p, q 皆為 odd</p>
<ul>
<li>因為 path y,a1,...ap,z 這段上面， M1 及 M2 必須有相同數目的 edges</li>
<li>因此 edge 數目為 even，vertex 數量則為 odd</li>
<li>又 <code>|V(C)| = 4 + p + q</code>， 為 even !</li>
<li>所以 p, q 相同都為 odd</li>
</ul>
</li>
<li>
<p>所以 edge 集合為 M*</p>
<ul>
<li>M* = {a1a2, ... , a(p-2)a(p-1), a(p)z, yx, b1b2, ... b(q-2)b(q-1), bqw} ，都屬於 E 集合（edge 總集合）</li>
<li>於下圖中<code>綠色</code>部份展示為一組 perfect matching 於 V(C)</li>
<li>下圖中<code>黃色</code>部份是展示 M1 - E(C) 為一組 perfect matching 於 V - V(C)</li>
<li>而這兩組取聯集後，成為 G 的一組 perfect matching ！ 因此符合 Tutte Condition !</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/toolbuddy/Graph-Theory/blob/master/res/ch3/g-tutte-case2-caseAB.png?raw=true" alt=""></p>
<p>如此我們便可以說，在符合 tutte condition 情況下，其必定有 1-factor 的存在</p>
<h2 id="Summary">Summary</h2>
<p>Case 1 的部份較為簡單，透過鴿籠原理即可證實。</p>
<p>Case 2 的部份主要是以<strong>一直符合 Tutte Condition 的 graph G</strong>，在差一條 edge 可以成為 "1-factor" <code>G'</code> 的假設為前提下去做的分析，透過證實在差一條 edge 可成為 1-factor 的這個性質來強調，分析下的 graph 皆為<code>假設下沒有 1-factor</code> 的這個情形。所以從這個 G 下去做分析，來證實 <code>只要符合 tutte condition，就一定有 1-factor 存在</code> 這個性質，說明前面假設部份為錯誤的假設情況。</p>
<h1 id="Reference">Reference</h1>
<ul>
<li><a href="http://ion.uwinnipeg.ca/~ychen2/advancedAD/notes-March15.pdf">notes-March15.pdf</a></li>
</ul>
<p></p></div><div class="content" id="content2"><p></p><h1 id="Linear%20Algebra">Linear Algebra</h1>
<h3 id="$Def$%20可加性(additivity) :" class=" cn">$Def$ 可加性(additivity) :</h3>
<ul>
<li>
<p>令 $f(x)$ 為一函數，$s,t \in D_f$。若$f(s) + f(t) = f(s+t) , \forall ~s,t$。則我們稱 $f(x)$ 具有<strong>可加性</strong></p>
</li>
<li>
<p>範例： Let $f(x)=87x$，$s,t \in D_f$.Then：
$f(s)+f(t)=87s+87t=87(s+t)=f(s+t)$
$Therefore, f(x)~is~an~additivity~function.$</p>
</li>
<li>
<p>範例：Let $f(x) = \int x {\rm d}x$，$s=ax+b~,~t=cx+d$.Then：
$s+t= (a+b)x+(c+d)$
$f(s) = \int (ax+b) {\rm d}x = \frac{1}{2}ax^2+bx+C$
$f(t) = \int (cx+d) {\rm d}x = \frac{1}{2}cx^2+dx+C$&lt;
$f(s)+f(t) = \frac{1}{2}(a+c)x^2+(b+d)x+C$
$f(s+t) = \int [(a+b)x+(c+d)] {\rm d}x = \frac{1}{2}(a+b)x^2+(c+d)x+C$
$f(s)+f(t)=f(s+t)=\frac{1}{2}(a+b)x^2+(c+d)x+C$
$f(x)$ is additivity when $s,t \in P_1$
作者碎碎念：事實上對於$n$次多項式都有這性質，就是微積分裡面常見的$\int (f(x) \pm g(x)) {\rm d}x = \int f(x) {\rm d}x \pm \int g(x) {\rm d}x$。不過在這邊我只是為了展示可加性，所以就不證明它了( ´ ▽ ` )ﾉ</p>
</li>
<li>
<p>範例：Let $f(x)=94x+87$，$s,t \in D_f.$Then：
$f(s)+f(t)=(94s+87)+(94t+87)=94(s+t)+174$
$f(s+t)=94(s+t)+87 \neq f(s)+f(t)=94(s+t)+174$
$Therefore, f(x)~is~not~an~additivity~function.$</p>
</li>
</ul>
<p></p></div></div></div><div class="to-top"><a class="paper-btn margin" href="#top">Top</a><div class="row flex-spaces child-borders"><label class="paper-btn margin" for="modal-1">T.O.C.</label></div></div><input class="modal-state" id="modal-1" type="checkbox"><div class="modal modal-dialog"><label class="modal-bg" for="modal-1"></label><div class="modal-body"><label class="btn-close" for="modal-1">X </label><h4 class="modal-title">Table of Content</h4><h5 class="modal-subtitle">Click and go !</h5><div class="modal-body" id="toc"><h4 class="modal-text">01-tutte's theorem</h4><hr><ol><li><a href="#Tutte's%20theorem">Tutte's theorem</a></li><a href="#Tutte's%20theorem">
</a><li><a href="#Tutte's%20theorem"></a><a href="#證明與概念詳細解釋">證明與概念詳細解釋</a></li><a href="#證明與概念詳細解釋">
</a><ol><a href="#證明與概念詳細解釋"></a><li><a href="#證明與概念詳細解釋"></a><a href="#Necessity（必要性）">Necessity（必要性）</a></li><a href="#Necessity（必要性）">
</a><li><a href="#Necessity（必要性）"></a><a href="#Sufficiency（充份性）">Sufficiency（充份性）</a></li><a href="#Sufficiency（充份性）">
</a><ol><a href="#Sufficiency（充份性）"></a><li><a href="#Sufficiency（充份性）"></a><a href="#先從假設的狀況下手">先從假設的狀況下手</a></li><a href="#先從假設的狀況下手">
</a><li><a href="#先從假設的狀況下手"></a><a href="#Claim%201">Claim 1</a></li><a href="#Claim%201">
</a><li><a href="#Claim%201"></a><a href="#Claim%202">Claim 2</a></li><a href="#Claim%202">
</a></ol><li><a href="#Summary">Summary</a></li><a href="#Summary">
</a></ol><li><a href="#Reference">Reference</a></li><a href="#Reference">
</a></ol><h4 class="modal-text">02-mathJax</h4><hr><ol><li><a href="#Linear%20Algebra">Linear Algebra</a></li><a href="#Linear%20Algebra">
</a><ol><a href="#Linear%20Algebra"></a><li><a href="#Linear%20Algebra"></a><a href="#$Def$%20可加性(additivity)" :="">$Def$ 可加性(additivity) :</a></li><a href="#$Def$%20可加性(additivity)" :="">
</a></ol></ol></div></div></div><div class="row flex-right"><p>Created by <span class="badge secondary">@ToolBuddy/papoGen(papercss)</span></p></div></div></div></body></html>